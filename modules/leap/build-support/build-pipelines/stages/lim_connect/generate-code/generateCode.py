# python libraries
import re
import sys

# AWB dependencies
from model import  *
from li_module import *

#local package includes
from generateMultiplexors import *

def getTargetPlatforms(platformGraph, platform):

    targetPlatforms = set()
    for channel in platformGraph.modules[platform].channels:
        targetPlatforms.add(channel.partnerChannel.module_name)
    for chain in platformGraph.modules[platform].chains:
        targetPlatforms.add(chain.sourcePartnerChain.module_name)
        targetPlatforms.add(chain.sinkPartnerChain.module_name)

    return targetPlatforms

def generateCodeBSV(moduleList, platform, environmentGraph, platformGraph):
    
    pipeline_debug = getBuildPipelineDebug(moduleList)

    ENABLE_TYPE_COMPRESSION = moduleList.getAWBParam('lim_connect', 'ENABLE_TYPE_COMPRESSION')
    GENERATE_ROUTER_DEBUG = moduleList.getAWBParam('lim_graph_generator', 'GENERATE_ROUTER_DEBUG')
    GENERATE_ROUTER_STATS = moduleList.getAWBParam('lim_graph_generator', 'GENERATE_ROUTER_STATS')

    # targetPlatforms - a list of platforms directly connected to platform
    targetPlatforms = getTargetPlatforms(platformGraph, platform)

    platformObject = platformGraph.modules[platform]

    headerFile = environmentGraph.getPlatform(platform).getAttribute('HEADER')
    header = open(headerFile, 'w')
   
    header.write('// Generated by build pipeline\n\n')
    header.write('`include "awb/provides/common_services.bsh"\n')
    header.write('`include "awb/provides/soft_connections.bsh"\n')
    header.write('`include "awb/provides/librl_bsv_base.bsh"\n')
    header.write('`include "awb/provides/librl_bsv_storage.bsh"\n')
    header.write('`include "awb/provides/multifpga_switch.bsh"\n')
    header.write('`include "awb/provides/physical_platform.bsh"\n')
    header.write('`include "awb/provides/multifpga_router_service.bsh"\n')
    header.write('import GetPut::*;\n')
    header.write('import FIFO::*;\n')    
    header.write('import FIFOF::*;\n')
    header.write('import SpecialFIFOs::*;\n')
    header.write('import Connectable::*;\n')
     
    # With compressed connections, we need other bo to be imported
    # TODO: This code is currently not working.  Needs to be fixed..
    #if(ENABLE_TYPE_COMPRESSION):
        #for targetPlatform in targetPlatforms:
        #    for dep in list(set(flatten(map(lambda dangling: dangling.type_structure.dependencies, \
        #                    self.platformData[platform]['CONNECTED'][targetPlatform])))):
        #        header.write('`include "awb/provides/' + dep + '.bsh"\n')

        # Dangling Connections for this platform may have some definitions.  We insert them here.
        #for targetPlatform in targetPlatforms:                               :
        #    for dangling in self.platformData[platform]['CONNECTED'][targetPlatform]:
        #        header.write(dangling.code.definition)

    # everything down here should be code generation.  Eventually it should be split out.  
    # probably also need to instantiate stats in a different modules
    egress_multiplexor_definitions = ''
    egress_multiplexor_instantiations = ''
    egress_multiplexor_names = {}
    ingress_multiplexor_definitions = ''
    ingress_multiplexor_instantiations = '' 
    ingress_multiplexor_names = {}

    # generate router code on a platform pair basis.  
    for targetPlatform in targetPlatforms:
        [egress_multiplexor_definition, egress_multiplexor_instantiation, egress_multiplexor_name] = generateEgressMultiplexor(platform, targetPlatform, moduleList, environmentGraph, platformGraph) 
        [ingress_multiplexor_definition, ingress_multiplexor_instantiation, ingress_multiplexor_name] = generateIngressMultiplexor(platform, targetPlatform, moduleList, environmentGraph, platformGraph)
        egress_multiplexor_definitions += egress_multiplexor_definition
        egress_multiplexor_instantiations += egress_multiplexor_instantiation 
        egress_multiplexor_names.update(egress_multiplexor_name)
        ingress_multiplexor_definitions += ingress_multiplexor_definition  
        ingress_multiplexor_instantiations += ingress_multiplexor_instantiation  
        ingress_multiplexor_names.update(ingress_multiplexor_name)               


    header.write(egress_multiplexor_definitions + ingress_multiplexor_definitions)

    # toss out the mapping functions first
    header.write('module [CONNECTED_MODULE] mkCommunicationModule#(PHYSICAL_DRIVERS physicalDrivers) (Empty);\n')

    header.write('String platformName <- getSynthesisBoundaryPlatform();\n')
    header.write('messageM("Instantiating Custom Router on " + platformName); \n')

    # Dangling Channels for this platform may have some declarations.  We insert them here.
    for targetPlatform in targetPlatforms:
        for dangling in channelsByPartner(platformObject, targetPlatform):
            header.write("// Compression code has been removed.\n")#dangling.code.declaration)

    header.write(egress_multiplexor_instantiations + ingress_multiplexor_instantiations)

    # chains can and will have two different communications outlets, therefore, the chains connections
    # cannot be filled in until after all the links are instantiated
    # the chain insertion code must lexically come after the arbiter instantiation
    chainsStr = ''

    # handle the connections themselves
    for targetPlatform in targetPlatforms:

        egressVias = environmentGraph.platforms[platform].getEgress(targetPlatform).logicalVias
        ingressVias = environmentGraph.platforms[platform].getIngress(targetPlatform).logicalVias
        header.write('// Connection to ' + targetPlatform + ' \n')
        sends = 0
        recvs = 0
        chains = 0
        stats = RouterStats( "router" + platform + "_" + targetPlatform)

        # Handle the soft connection declarations of for each
        # channel between platform and targetPlatform.            
        for dangling in channelsByPartner(platformObject,targetPlatform):
            if(pipeline_debug):
                print "Laying down " + dangling.name + " of type " + dangling.sc_type + " on " + dangling.platform

            if(dangling.isSource()): # this channel is egress
                if(ENABLE_TYPE_COMPRESSION and dangling.type_structure.compressable):
                        header.write('\nCONNECTION_RECV#(' +  dangling.raw_type + ') recv_uncompressed_' + dangling.name + ' <- mkPhysicalConnectionRecv("' + dangling.name + '", tagged Invalid, False, "' + dangling.raw_type + '");\n')
                        #header.write('COMPRESSION_ENCODER#(' + dangling.raw_type + ',enc_type_'+ dangling.inverse_name +') recv_' + dangling.inverse_name + '_compressed <- mkCompressor();\n')
                        header.write('let recv_' + dangling.name + '_compressed <- mkCompressor();\n')
                        header.write('Put#('+ dangling.raw_type + ') put_' + dangling.name + '_compressed = toPut(recv_' + dangling.name + '_compressed);\n')
                        header.write('mkConnection(put_' + dangling.name + '_compressed, toGet(recv_uncompressed_' + dangling.name + '));\n')
                        header.write('let recv_' + dangling.name +' = toConnectionRecv(recv_' + dangling.name + '_compressed);\n\n')
                else:
                    header.write('\nCONNECTION_RECV#(Bit#(PHYSICAL_CONNECTION_SIZE)) recv_' + dangling.name + ' <- mkPhysicalConnectionRecv("' + dangling.name + '", tagged Invalid, False, "' + dangling.raw_type + '");\n')
                if(GENERATE_ROUTER_STATS):
                    stats.addCounter('blocked_' + dangling.name,
                                     'ROUTER_' + dangling.name + '_BLOCKED',
                                     dangling.name + ' on egress' + str(dangling.via_idx_egress) + ' link ' + str(dangling.via_link_egress) + 'cycles blocked')

                    stats.addCounter('sent_' + dangling.name,
                                     'ROUTER_' + dangling.name + '_SENT',
                                     dangling.name + ' on egress' + str(dangling.via_idx_egress) + ' link ' + str(dangling.via_link_egress) + ' cycles sent') 
           
                recvs += 1 

          
          
            else: # This channel is ingress
                if(GENERATE_ROUTER_STATS > 1):
                    stats.addCounter('received_' + dangling.name,
                                     'ROUTER_' + dangling.name + '_RECEIVED',
                                     dangling.name + ' on ingress' + str(dangling.via_idx_ingress) + ' link ' + str(dangling.via_link_ingress) + ' received cycles')

                if(ENABLE_TYPE_COMPRESSION and dangling.type_structure.compressable):
                    header.write('PHYSICAL_SEND#(' +  dangling.raw_type + ') send_uncompressed_' + dangling.name + ' <- mkPhysicalConnectionSend("' + dangling.name + '", tagged Invalid, False, "' + dangling.raw_type + '", True);\n')
                    
                    header.write('let send_' + dangling.name + '_decompressed <- mkDecompressor();\n')
                    header.write('Get#('+ dangling.raw_type + ') get_' + dangling.name + '_decompressed = toGet(send_' + dangling.name + '_decompressed);\n')
                    header.write('mkConnection(get_' + dangling.name + '_decompressed, toPut(send_uncompressed_' + dangling.name + '));\n')
                    header.write('let send_' + dangling.name + ' <- mkPhysicalSend(send_' + dangling.name + '_decompressed);\n\n')
                else:
                    header.write('PHYSICAL_SEND#(Bit#(PHYSICAL_CONNECTION_SIZE)) send_' + dangling.name + ' <- mkPhysicalConnectionSend("' + dangling.name + '", tagged Invalid, False, "' + dangling.raw_type + '", True);\n')
                sends += 1
      

        # Handle Chains seperately
        for dangling in ingressChainsByPartner(platformObject,targetPlatform):
            chains += 1 

            if(GENERATE_ROUTER_STATS > 1):
                stats.addCounter('received_' + dangling.name,
                                 'ROUTER_' + platform + '_' + targetPlatform + '_' + dangling.name + '_RECEIVED',
                                 dangling.name + ' on ingress' + str(dangling.via_idx_ingress) + ' link ' + str(dangling.via_link_ingress) +' received cycles')

            # we must create a logical chain information
            chainsStr += 'let chain_' + dangling.name + ' = ' + \
                         'LOGICAL_CHAIN_INFO{logicalName: "' + dangling.name + '", ' + \
                         'logicalType: "' + dangling.raw_type + '", ' + \
                         'incoming: tpl_2(pack_chain_' + dangling.name + '), ' + \
                         'outgoing: unpack_chain_' + dangling.name + ', ' + \
                         'bitWidth: ' + str(dangling.bitwidth) + ', ' + \
                         'moduleNameIncoming: "router", moduleNameOutgoing: "router"' + \
                         '};\n'
                  
            chainsStr += 'registerChain(chain_' + dangling.name + ');\n'

        for dangling in egressChainsByPartner(platformObject,targetPlatform):
            if(GENERATE_ROUTER_STATS):
                stats.addCounter('blocked_chain_' + dangling.name,
                                 'ROUTER_' + platform + '_' + targetPlatform + '_' + dangling.name + '_BLOCKED',
                                 dangling.name + ' on egress' + str(dangling.via_idx_egress) + ' link ' + str(dangling.via_link_egress) + ' cycles blocked')

                stats.addCounter('sent_chain_' + dangling.name,
                                 'ROUTER_' + platform + '_' + targetPlatform + '_' + dangling.name + '_SENT',
                                 dangling.name + ' on egress' + str(dangling.via_idx_egress) + ' link ' + str(dangling.via_link_egress) + ' cycles sent')

        header.write(stats.genStats())

        # Ingress switches now feed directly into the egress switches to save latency.  
        for via_idx in range(len(ingressVias)):
            if(ingressVias[via_idx].via_links > 0):
                header.write('INGRESS_SWITCH#(' + str(ingressVias[via_idx].via_links) + ',' + ingressVias[via_idx].umfType.typeBSV() + ',' + egressVias[ingressVias[via_idx].via_outgoing_flowcontrol_via].umfType.headerTypeBSV() + ',' + egressVias[ingressVias[via_idx].via_outgoing_flowcontrol_via].umfType.bodyTypeBSV() + ') ' + ingressVias[via_idx].via_switch + '<- mkIngressSwitch(' + str(ingressVias[via_idx].via_outgoing_flowcontrol_link) + ',' + ingress_multiplexor_names[targetPlatform] + '.' + ingressVias[via_idx].via_method  + '_first, ' + ingress_multiplexor_names[targetPlatform] + '.' + ingressVias[via_idx].via_method  + '_deq);\n\n')

        # The egress links now take as input a list of incoming connections
        # that can be manipulated like fifos.  
        egressVectors = []
        for via_idx in range(len(egressVias)):
            if(pipeline_debug):
                print "Working on " + egressVias[via_idx].via_switch + ' with Links: ' + str(egressVias[via_idx].via_links)

            egressVectors.append(["?" for x in range(egressVias[via_idx].via_links)]) # we could also do a double list comprehension.

        # the egress links need to go first, since they are provided as an argument to the 
        # switches           
        for dangling in egressChannelsByPartner(platformObject, targetPlatform):
            packetizerType = 'Marshalled'
            header.write('NumTypeParam#('+ str(dangling.bitwidth) +') width_recv_' + dangling.name +' = ?;\n')
            egressVectors[dangling.via_idx_egress][dangling.via_link_egress] = 'pack_recv_' + dangling.name

            packetizerType = 'NoPack'
            # Software only handles unmarshalled packets for now...
            if(environmentGraph.getPlatform(targetPlatform).platformType == 'FPGA' or environmentGraph.getPlatform(targetPlatform).platformType == 'BLUESIM'):
                packetizerType = 'Marshalled'
                if(dangling.bitwidth <= egressVias[dangling.via_idx_egress].via_filler_width):            
                    packetizerType = 'Unmarshalled'

            header.write('// Via' + str(egressVias[dangling.via_idx_egress].via_width) + ' mine:' + str(dangling.bitwidth) + '\n')
            header.write('let pack_recv_' + dangling.name + ' <- mkPacketizeConnectionReceive' + packetizerType + '(\n')
            header.write('\t"' + dangling.name + '",\n')
            header.write('\t' + str(dangling.via_link_egress) + ',\n')
            header.write('\twidth_recv_' + dangling.name + ',\n')

            if(GENERATE_ROUTER_STATS):
                header.write('\t' + stats.incrCounter('blocked_' + dangling.name) + ',\n')
                header.write('\t' + stats.incrCounter('sent_' + dangling.name) + ',\n')
            else:
                header.write('\t?, ?,\n')

            header.write('\trecv_' + dangling.name + ');\n\n')

        #Handle Chains seperately
        for dangling in egressChainsByPartner(platformObject, targetPlatform):
            header.write('// Via' + str(egressVias[dangling.via_idx_egress].via_width) + ' mine:' + str(dangling.bitwidth) + '\n')
            #header.write('NumTypeParam#(PHYSICAL_CONNECTION_SIZE) width_chain_' + dangling.name +' = ?;\n')
            header.write('NumTypeParam#('+ str(dangling.bitwidth) +') width_chain_' + dangling.name +' = ?;\n')
            egressVectors[dangling.via_idx_egress][dangling.via_link_egress] = 'tpl_1(pack_chain_' + dangling.name + ')'
            packetizerType = 'NoPack'
            # Software only handles unmarshalled packets for now...
            if(environmentGraph.getPlatform(targetPlatform).platformType == 'FPGA' or environmentGraph.getPlatform(targetPlatform).platformType == 'BLUESIM'):
                packetizerType = 'Marshalled'
                if(dangling.bitwidth <= egressVias[dangling.via_idx_egress].via_filler_width):
                    packetizerType = 'Unmarshalled'

            if(pipeline_debug):
                print "Chain Sink " + dangling.name + ": Idx " + str(dangling.via_idx_egress) + " Link: " + str(dangling.via_link_egress) + " Length: " + str(len(egressVectors[dangling.via_idx_egress]))  
                print "Choosing Incoming Marshalling with " + str(egressVias[dangling.via_idx_egress].via_filler_width) +   " + " + str(egressVias[dangling.via_idx_egress].via_width) + "(" +  str(egressVias[dangling.via_idx_egress].via_width + egressVias[dangling.via_idx_egress].via_filler_width) + ") < " + str(dangling.bitwidth) + " = " + packetizerType

            header.write('let pack_chain_' + dangling.name + ' <- mkPacketizeIncomingChain' + packetizerType + '(\n')
            header.write('\t"' + dangling.name + '",\n')
            header.write('\t' + str(dangling.via_link_egress) + ',\n')
            header.write('\twidth_chain_' + dangling.name + ',\n')

            if(GENERATE_ROUTER_STATS):
                header.write('\t' + stats.incrCounter('blocked_chain_' + dangling.name) + ',\n')
                header.write('\t' + stats.incrCounter('sent_chain_' + dangling.name) + ');\n\n')
            else:
                header.write('\t?, ?);\n\n')

      
        # we now need switches for each via.  Need modular arithmetic here to make sure that everyone has a link.  
        # for now we will assume that flow control is twinned - that is the egress 2 uses ingress 2 for its flow control
        # this might well need to change as we introduce assymetry x_X
        # we actually should be allocating the feedback channel as part of the analysis phase, but that can happen later.             
        via_dbg = 'via_' + platform + '_' + targetPlatform + '_dbg_list';

        if (GENERATE_ROUTER_DEBUG):      
            header.write('\nDEBUG_SCAN_FIELD_LIST ' + via_dbg + ' = List::nil;\n')


        for via_idx in range(len(egressVias)):
            if(egressVias[via_idx].via_links > 0):                
                # create array of links for constructor
                # we may have many flow control links
                # these no longer necessarily occur at the head of the list
                for ingressVia in ingressVias:
                    if(ingressVia.via_outgoing_flowcontrol_via == via_idx):
                        egressVectors[via_idx][ingressVia.via_outgoing_flowcontrol_link] = ingressVia.via_switch + ".flowcontrol_response"

                linkArray = "{"  
                
                # TODO: replace this with something more pythonic, like a .join.
                firstPass = True
                for link_idx in range(egressVias[via_idx].via_links): # this seems off by one?
                    seperator = ',// link idx:'+ str(link_idx - 1) +'\n\t'
                    if(firstPass):
                        seperator = '\n\t';
                    linkArray += seperator + egressVectors[via_idx][link_idx]  
                    firstPass = False
                  
                linkArray += "}// link idx: " + str(egressVias[via_idx].via_links - 1)  + '\n'

                if(pipeline_debug):
                    print "Idx: " + str(via_idx) + " eg vias len" + str(len(egressVias)) + " in vias len" + str(len(ingressVias))

                header.write('EGRESS_PACKET_GENERATOR#(' + egressVias[via_idx].umfType.headerTypeBSV() + ', ' +  egressVias[via_idx].umfType.bodyTypeBSV() + ') links_' + egressVias[via_idx].via_switch + '[' + str(egressVias[via_idx].via_links) + '] = ' + linkArray + ';\n') 

                # If there are few enough incoming ports then router arbitration
                # can be done in a single cycle.  Otherwise, use multiple cycles.
                single_cycle_arb = 'True'
                if (egressVias[via_idx].via_links > 10):
                    single_cycle_arb = 'False'

                header.write('EGRESS_SWITCH#(' + str(egressVias[via_idx].via_links) + ') ' + egressVias[via_idx].via_switch + '<- mkEgressSwitch( links_' + egressVias[via_idx].via_switch + ', ' + ingressVias[egressVias[via_idx].via_outgoing_flowcontrol_via].via_switch + '.ingressPorts[' + str(egressVias[via_idx].via_outgoing_flowcontrol_link) +'], compose(' + egress_multiplexor_names[targetPlatform] + '.' + egressVias[via_idx].via_method + ',pack), "' + egressVias[via_idx].via_switch + '", ' + single_cycle_arb + ');\n')

                if(GENERATE_ROUTER_DEBUG):   
                    header.write(via_dbg + ' <- addDebugScanField(' + via_dbg + ', "' + egressVias[via_idx].via_switch + ' buffer status", ' + egressVias[via_idx].via_switch + '.bufferStatus);\n')
                    header.write(via_dbg + ' <- addDebugScanField(' + via_dbg + ', "' + egressVias[via_idx].via_switch + ' fifo status", ' + egressVias[via_idx].via_switch + '.fifoStatus);\n')
          
        if(GENERATE_ROUTER_DEBUG):   
            header.write('let ' + via_dbg + '_Node <- mkDebugScanNode("Multi-FPGA Router Egress VIAs", ' + via_dbg + ' );\n')

        # Hook up the ingress links
        # We also want to build a listing of the mapping in an easy to consume 
        # human readable format.  Therefore, we first sort the connections by assignment.            
        # and dump a link manifest.
        maximumLinks = max(ingressVias, key = lambda via: via.via_links).via_links;
        sortedIngressLinks = sorted(ingressChainsByPartner(platformObject,targetPlatform) + ingressChannelsByPartner(platformObject,targetPlatform), key = lambda dangling: dangling.via_link_ingress + maximumLinks * dangling.via_idx_ingress) # sorted is ascending

        for dangling in sortedIngressLinks:
            header.write('// ' + dangling.name + ' via_idx: ' + str(dangling.via_idx_ingress) + ' link_idx: ' +  str(dangling.via_link_ingress) + '\n')

        # and now we actually generate the connections
        for dangling in ingressChannelsByPartner(platformObject, targetPlatform):
            header.write('NumTypeParam#('+ str(dangling.bitwidth) +') width_send_' + dangling.name +' = ?;\n\n')
            packetizerType = 'NoPack'
            # Software only handles unmarshalled packets for now...
            if(environmentGraph.getPlatform(targetPlatform).platformType == 'FPGA' or environmentGraph.getPlatform(targetPlatform).platformType == 'BLUESIM'):
                packetizerType = 'Marshalled'
                if(dangling.bitwidth <= ingressVias[dangling.via_idx_ingress].via_width + ingressVias[dangling.via_idx_ingress].via_filler_width):            
                    packetizerType = 'PartialMarshalled'
                if(dangling.bitwidth <= ingressVias[dangling.via_idx_ingress].via_filler_width):
                    packetizerType = 'Unmarshalled'

            header.write('// Via' + str(ingressVias[dangling.via_idx_ingress].via_width) + ' mine:' + str(dangling.bitwidth) + '\n')
            header.write('Empty unpack_send_' + dangling.name + ' <- mkPacketizeConnectionSend' + packetizerType  + '(\n')
            header.write('\t"' + dangling.name + '",\n')
            header.write('\t' + ingressVias[dangling.via_idx_ingress].via_switch + '.ingressPorts[' + str(dangling.via_link_ingress) + '],\n')
            header.write('\t' + str(dangling.via_link_ingress) + ',\n')
            header.write('\twidth_send_' + dangling.name + ',\n')
            if(GENERATE_ROUTER_STATS > 1):
                header.write('\t' + stats.incrCounter('received_' + dangling.name) + ',\n')
            else:
                header.write('\t?,\n')

            header.write('\tsend_' + dangling.name + ');\n\n')

        # handle chains seperately
        for dangling in ingressChainsByPartner(platformObject, targetPlatform):
            if(pipeline_debug or True):
                print "My type: " + dangling.sc_type
                print "My raw type: " + dangling.raw_type
                print "My name: " + dangling.name
                print "My via ingress: " + str(dangling.via_idx_ingress)

            header.write('NumTypeParam#('+ str(dangling.bitwidth) +') width_sink_' + dangling.name +' = ?;\n')
          
            packetizerType = 'NoPack'
            print "IngressVias: " + str(ingressVias)
            header.write('// Via' + str(ingressVias[dangling.via_idx_ingress].via_width) + ' mine:' + str(dangling.bitwidth) + '\n')

            # Software only handles unmarshalled packets for now...
            if(environmentGraph.getPlatform(targetPlatform).platformType == 'FPGA' or environmentGraph.getPlatform(targetPlatform).platformType == 'BLUESIM'):
                packetizerType = 'Marshalled'

                if(dangling.bitwidth <= (ingressVias[dangling.via_idx_ingress].via_width + ingressVias[dangling.via_idx_ingress].via_filler_width)): 
                    packetizerType = 'PartialMarshalled'

                if(dangling.bitwidth <= ingressVias[dangling.via_idx_ingress].via_filler_width):            
                    packetizerType = 'Unmarshalled'

            if(pipeline_debug):
                print "Choosing Marshalling with " + str(ingressVias[dangling.via_idx_ingress].via_filler_width) +   " + " + str(ingressVias[dangling.via_idx_ingress].via_width) + "(" +  str(ingressVias[dangling.via_idx_ingress].via_width + ingressVias[dangling.via_idx_ingress].via_filler_width) + ") < " + str(dangling.bitwidth) + " = " + packetizerType

            header.write('PHYSICAL_CHAIN_OUT unpack_chain_' + dangling.name + ' <- mkPacketizeOutgoingChain' + packetizerType + '(\n')
            header.write('\t"' + dangling.name + '",\n')
            header.write('\t' + ingressVias[dangling.via_idx_ingress].via_switch + '.ingressPorts[' + str(dangling.via_link_ingress) + '],\n')
            header.write('\t' + str(dangling.via_link_ingress) + ',\n')
            header.write('\twidth_sink_' + dangling.name + ',\n')
            if(GENERATE_ROUTER_STATS > 1):
                header.write('\t' + stats.incrCounter('received_' + dangling.name) + ');\n\n')
            else:
                header.write('\t?);\n\n')
    
    # End for target in targetPlatforms


    # Add in chain insertion code 
    header.write(chainsStr + '\n')

    header.write('endmodule\n')
    header.close();

      
# this needs to be translated. 
def generateCodeCPP(moduleList, platform, environmentGraph, platformGraph):

    pipeline_debug = getBuildPipelineDebug(moduleList)

    platformObject = platformGraph.modules[platform]

    targetPlatforms = getTargetPlatforms(platformGraph, platform)

    headerFile = environmentGraph.getPlatform(platform).getAttribute('HEADER')

    header = open(headerFile, 'w')
    header.write('// Generated by build pipeline\n\n')
    header.write('#ifndef __SW_ROUTING__\n')
    header.write('#define __SW_ROUTING__\n')
    header.write('#include "awb/provides/physical_channel.h"\n')
    header.write('#include "awb/provides/channelio.h"\n')
    header.write('#include "awb/provides/multifpga_switch.h"\n')
    header.write('#include "awb/provides/umf.h"\n')
    header.write('#include <pthread.h>\n')
    header.write('#include <vector>\n')
    header.write('#include "tbb/concurrent_queue.h"\n')

    header.write('using namespace std;\n')
    #write out threads for each I/O channel
    def incomingName(platformName, targetPlatformName):
        return "inFrom" + targetPlatformName 

    def outgoingName(platformName, targetPlatformName):
        return "outTo" + targetPlatformName 

    def incomingThreadFuncName(platformName, targetPlatformName):
        return incomingName(platformName, targetPlatformName) + "Thread"

    def outgoingThreadFuncName(platformName, targetPlatformName):
        return outgoingName(platformName, targetPlatformName) + "Thread"

    #factories for physical UMFs. Notice that these constructors need not be the same. 
    egressFactoryNames = []
    ingressFactoryNames = []
    factoryInitializers = []
    # Each physical channel will have its own set of incoming/outgoing channels.
    incomingChannels = {}
    outgoingChannels = {}
    flowcontrolInit = []

    # This generates per via structures.
    for targetPlatform in targetPlatforms:
        hopFromTarget = environmentGraph.transitTablesIncoming[platform][targetPlatform]
        hopToTarget = environmentGraph.transitTablesOutgoing[platform][targetPlatform]  

        incomingChannels[targetPlatform] = []
        outgoingChannels[targetPlatform] = []


        egressVias = environmentGraph.platforms[platform].getEgress(targetPlatform).logicalVias
        ingressVias = environmentGraph.platforms[platform].getIngress(targetPlatform).logicalVias

        if(pipeline_debug):
            print "EGRESS: " + str(egressVias.keys()) + " : " + str(egressVias)
            print "INGRESS: " + str(ingressVias.keys()) + " : " + str(ingressVias)

        # To do - if we have more have more than one via, this code ought to be in a loop.

        header.write(egressVias[0].umfType.factoryClassCPP(hopToTarget + "_OUTGOING"))
        header.write("\n\n")

        header.write(ingressVias[0].umfType.factoryClassCPP(hopFromTarget + "_INCOMING"))
        header.write("\n\n")

        egressFactoryName = egressVias[0].umfType.factoryClassNameCPP(hopToTarget + "_OUTGOING")
        egressFactoryNames.append(egressFactoryName)
        ingressFactoryName = ingressVias[0].umfType.factoryClassNameCPP(hopFromTarget + "_INCOMING")
        ingressFactoryNames.append(ingressFactoryName)
  
        factoryInitializers += ['\t\t' + hopFromTarget +'->SetUMFFactory(new ' + ingressFactoryName + '());\n'] 
        factoryInitializers += ['\t\t' + hopToTarget +'->SetUMFFactory(new ' + egressFactoryName + '()); \n'] 

        viaIdx = range(len(ingressVias))    
        for via in ingressVias:

            outgoingChannels[targetPlatform].append('\t\toutgoingChannels["' + targetPlatform + '"]->at(' + str(via.via_outgoing_flowcontrol_link) + ') = new  FLOWCONTROL_OUT_CLASS(incomingChannels["' + targetPlatform + '"],mergedOutQ["'+ targetPlatform +'"]);\n')

            flowcontrolInit.append('\t\t((FLOWCONTROL_OUT_CLASS*)outgoingChannels["' + targetPlatform + '"]->at(' + str(via.via_outgoing_flowcontrol_link) + '))->Init();\n')
            viaIdx.pop()

        viaIdx = range(len(egressVias))    

        if(len(egressVias) != 1  or len(ingressVias) != 1):
            print "Error: software platforms can't handle more than one via per link...: "
            sys.exit(-1)

        for via in egressVias:
            print "Via is " + str(via) + ' FC index ' + str(via.via_outgoing_flowcontrol_link) + '\n'  
            incomingChannels[targetPlatform].append('\t\tincomingChannels["' + targetPlatform + '"]->at(' + str(via.via_outgoing_flowcontrol_link) + ') = new FLOWCONTROL_IN_CLASS(outgoingChannels["' + targetPlatform + '"],mergedOutQ["'+ targetPlatform + '"],(UMF_FACTORY) new ' + egressFactoryNames[via.via_outgoing_flowcontrol_via] + '(),' + str(via.via_outgoing_flowcontrol_link) +');\n')

            flowcontrolInit.append('\t\t((FLOWCONTROL_IN_CLASS*)incomingChannels["' + targetPlatform + '"]->at(' + str(via.via_outgoing_flowcontrol_link) + '))->Init();\n')
            viaIdx.pop()
              




    header.write("typedef class CHANNELIO_CLASS* CHANNELIO;\n")
    header.write("class CHANNELIO_CLASS:  public CHANNELIO_BASE_CLASS\n")
    header.write("{\n")
    header.write("  private:\n")
    header.write("\t// Build up physical channels for this platform\n\n")                                                          
    header.write("\tpthread_t       ReaderThreads[" + str(len(targetPlatforms)) + "];\n")
    header.write("\tpthread_t       WriterThreads[" + str(len(targetPlatforms)) + "];\n")

    header.write("\n\n")

    #vectors for dangling connections
    platformSends = []
    platformRecvs = []
    deviceConstructors = []
    connections = range(len(targetPlatforms))
    for targetPlatform in targetPlatforms:  
        # strong assumption that hopFromTarget and hopToTarget are the same.  We 
        # need some syntax for this.
        hopFromTarget = environmentGraph.transitTablesIncoming[platform][targetPlatform]

        channels = channelsByPartner(platformObject, targetPlatform)
        sends = 0
        recvs = 0
        for dangling in channels:
            if(dangling.sc_type == 'Recv'):
                recvs = recvs + 1
            elif(dangling.sc_type == 'Send'):
                sends = sends + 1
            else:
                print "Error: software can't handle chains at this time...:  " + str(dangling)
                sys.exit(-1)
                
    header.write("\tmap<string, tbb::concurrent_bounded_queue<UMF_MESSAGE>*> mergedOutQ;\n")
    connections.pop()

    platformSends.append(sends)
    platformRecvs.append(recvs)


    header.write("  public:\n")
    header.write("\tCHANNELIO_CLASS(PLATFORMS_MODULE module, PHYSICAL_DEVICES physicalDevicesInit):\n")
    header.write("\t\tCHANNELIO_BASE_CLASS(module, physicalDevicesInit)\n")
    header.write("\n\t{\n");

    # we don't control the physical devices, yet we need to hand them specialized allocators. 
    # we do that here. 
    header.write("\t\t//Set up allocators\n\n");   

    for initializer in factoryInitializers:
        header.write(initializer)


    header.write("\t\t//Plumb connections\n\n");        
    connections = range(len(targetPlatforms))

    magicTypeTable = {'umf_cn__cn_GENERIC_UMF_PACKET_po__lp_umf_cn__cn_GENERIC_UMF_PACKET_HEADER_po__lp_4_cm__s_8_cm__s_4_cm__s_10_cm__s_6_cm__s_96_rp__cm__s_Bit_po__lp_128_rp__rp_': 'UMF_MESSAGE', 
                      'Bit_po__lp_128_rp_': 'UINT128'}

    # During the second pass, we assign the data types.  But we must know how many channels there are.
    # TODO: Maybe sends and receives are reversed here.
    for targetPlatform in targetPlatforms:
        for dangling in channelsByPartner(platformObject, targetPlatform):      
            #danglingTypeHack = "UMF_MESSAGE"
            # For now, we use the vanilla MARSHALLED_LI_CHANNEL_IN_CLASS for chain route-throughs
            # However, route-throughs require special handling. 
            if(dangling.sc_type == 'Recv' and isinstance(dangling.partnerChannel,LIChannel)):
                if(pipeline_debug):
                    print " CPU lays down (inverse Recv)" + str(dangling) 

                #these need to be ordered so that the index operator in the read thread will do the right thing.  
                incomingChannels[targetPlatform].append('\t\tincomingChannels["' + targetPlatform + '"]->at(' + str(dangling.via_link_ingress) + ') = new MARSHALLED_LI_CHANNEL_IN_CLASS<' + magicTypeTable[dangling.CPPType()] +'>(mergedOutQ["'+ targetPlatform +'"], "'+ dangling.name + '", (UMF_FACTORY) new ' + egressFactoryNames[ingressVias[0].via_outgoing_flowcontrol_via] +'(), ' + str(ingressVias[0].via_outgoing_flowcontrol_link) + ');//' +  str(dangling.via_link_ingress) +'\n\n')
            elif(dangling.sc_type == 'Recv' and isinstance(dangling.partnerChannel,LIChain)):
                incomingChannels[targetPlatform].append('\t\tincomingChannels["' + targetPlatform + '"]->at(' + str(dangling.via_link_ingress) + ') = new ROUTE_THROUGH_LI_CHANNEL_IN_CLASS(mergedOutQ["'+ targetPlatform +'"], "'+ dangling.name + '", (UMF_FACTORY) new ' + egressFactoryNames[ingressVias[0].via_outgoing_flowcontrol_via] +'(), ' + str(ingressVias[0].via_outgoing_flowcontrol_link) + ');//' +  str(dangling.via_link_ingress) +'\n\n')
            elif(dangling.sc_type == 'Send' and isinstance(dangling.partnerChannel,LIChannel)):
                if(pipeline_debug):
                    print " CPU lays down (inverse Send) " + str(dangling) 

                outgoingChannels[targetPlatform].append('\t\toutgoingChannels["' + targetPlatform + '"]->at(' + str(dangling.via_link_egress) + ') = new MARSHALLED_LI_CHANNEL_OUT_CLASS<' + magicTypeTable[dangling.CPPType()] +'>(mergedOutQ["'+ targetPlatform +'"],(UMF_FACTORY) new ' + egressFactoryNames[connections[0]] + '(),\n\t\t"'+ dangling.name + '",' + str(dangling.via_link_egress) + ');\n\n')
            elif(dangling.sc_type == 'Send' and isinstance(dangling.partnerChannel,LIChain)):
                outgoingChannels[targetPlatform].append('\t\toutgoingChannels["' + targetPlatform + '"]->at(' + str(dangling.via_link_egress) + ') = new ROUTE_THROUGH_LI_CHANNEL_OUT_CLASS(mergedOutQ["'+ targetPlatform +'"],(UMF_FACTORY) new ' + egressFactoryNames[connections[0]] + '(),\n\t\t"'+ dangling.name + '",' + str(dangling.via_link_egress) + ');\n\n')
            else:
                print "Unknown Connection in CPP Code Gen: " + str(dangling)
                exit(1)



    # During the first pass, we construct the data types.  From the preceding loop, we know the number of channels.

    for targetPlatform in targetPlatforms:
        hopFromTarget = environmentGraph.transitTablesIncoming[platform][targetPlatform]
        header.write('\t\tincomingChannels["' + targetPlatform + '"] = (new vector<LI_CHANNEL_IN>());\n')
        header.write('\t\toutgoingChannels["' + targetPlatform + '"] = (new vector<LI_CHANNEL_OUT>());\n')
        #header.write('\t\tmergedOutQ.push_back(new tbb::concurrent_bounded_queue<UMF_MESSAGE>());\n')
        header.write('\t\tmergedOutQ["' + targetPlatform + '"] = (' + hopFromTarget +'->GetWriteQ());\n')
        header.write('\t\t' + hopFromTarget +'->RegisterLogicalDeviceName("' + targetPlatform + '");\n')

        for channel in incomingChannels[targetPlatform]:              
            header.write('\t\tincomingChannels["' + targetPlatform + '"]->push_back(NULL);/*' + channel+ '*/\n')
        for channel in outgoingChannels[targetPlatform]:                                           
            header.write('\t\toutgoingChannels["' + targetPlatform + '"]->push_back(NULL);/*' + channel + '*/\n')

    # we've collected all of the channels, now emit them.
    for targetPlatform in targetPlatforms:          
        for channel in incomingChannels[targetPlatform] + outgoingChannels[targetPlatform]:
            header.write(channel)

    for init in flowcontrolInit:
        header.write(init)

    header.write("\t};//End of class constructor\n\n");
    connections.pop()



    header.write("\tvoid Init()\n");
    header.write("\t{\n");

    header.write("\t\t//Instantiate Threads\n\n");
    header.write("\t\tvoid ** readerArgs = NULL;\n")  
    header.write("\t\tvoid ** writerArgs = NULL;\n")  
    connections = range(len(targetPlatforms))
    for targetPlatform in targetPlatforms:
        hopFromTarget = environmentGraph.transitTablesIncoming[platform][targetPlatform]
        hopToTarget = environmentGraph.transitTablesOutgoing[platform][targetPlatform]  
        header.write("\t\treaderArgs = (void**) malloc(2*sizeof(void*));\n")
        header.write("\t\treaderArgs[0] = " + hopFromTarget + ";\n")
        header.write('\t\treaderArgs[1] = incomingChannels["' + targetPlatform + '"];\n')
        header.write("\t\tif (pthread_create(&ReaderThreads[" + str(connections[0]) + "],\n")
        header.write("\t\t                   NULL,\n")
        header.write("\t\t                   handleIncomingMessages,\n")
        header.write("\t\t                   readerArgs))\n")
        header.write("\t\t{\n")
        header.write('\t\t\tperror("pthread_create, ' + incomingThreadFuncName(platform, targetPlatform) + ':");\n')
        header.write("\t\t\texit(1);\n")
        header.write("\t\t}\n")

        header.write("\t\n")                                                                        
        connections.pop()

    header.write("\t};//End of class Init\n\n");


    header.write("\t~CHANNELIO_CLASS(){};\n")

    header.write("};\n\n")
    header.write('#endif\n')

    header.close();

def generateCode(moduleList, environmentGraph, platformGraph):
    # now that everything is matched we can ostensibly generate the header file
    # header must include device mapping as well

    # really, this is a pairwise decision, but for now we'll assume the underlying calls will 
    # interrogate the type of their counterpart.

    pipeline_debug = getBuildPipelineDebug(moduleList)
    if(pipeline_debug):
        for platformName in environmentGraph.getPlatformNames(): 
            platform = environmentGraph.getPlatform(platformName)         
            targetPlatforms = getTargetPlatforms(platformGraph, platformName)
            for targetPlatform in targetPlatforms:
                egressVias = environmentGraph.platforms[platformName].getEgress(targetPlatform).logicalVias
                ingressVias = environmentGraph.platforms[targetPlatform].getIngress(platformName).logicalVias
                print "For Egress " + platformName + ' -> ' + targetPlatform + ": " + str(egressVias)
                print "For Ingress " + platformName + ' <- ' + targetPlatform + ": " + str(ingressVias)
        
    for platformName in environmentGraph.getPlatformNames():          
        platformObject = environmentGraph.getPlatform(platformName)
        if(platformObject.platformType == 'CPU'):
            generateCodeCPP(moduleList, platformName, environmentGraph, platformGraph)
        if(platformObject.platformType == 'FPGA'  or platformObject.platformType == 'BLUESIM'):
            generateCodeBSV(moduleList, platformName, environmentGraph, platformGraph)

