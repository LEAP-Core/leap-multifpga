# python libraries
import re
import math
import os.path
import shutil

# AWB dependencies
from li_module import LIModule, LIChain

######################################################################
#
#  Latency-insensitive Module Scratchpad Connection Remapping
#
######################################################################

class Scratchpad():
    def __init__(self, id, ringBaseName, platformId=0, bandwidth=0):
        self.id = id
        self.ringBaseName = ringBaseName
        self.platformId = platformId
        self.bandwidth = bandwidth
    def __eq__(self, other):
        return self.__dict__ == other.__dict__

#
# This function separates scratchpad chains into a list of available 
# scratchpad controllers and a list of client scratchpad IDs 
# 
def separateScratchpadChains(chains):
    controllers = []
    clients = []
    for chain in chains: 
        m = re.match("(.*)_(?:Req|Resp)_(\d+)", chain)
        if m:
            client = Scratchpad(m.group(2), m.group(1))
            if client not in clients:
                clients.append(client)
        else:
            n = re.match("(.*)_(?:Req|Resp)", chain)
            if n: 
                if n.group(1) not in controllers:
                    controllers.append(n.group(1))
    return controllers, clients

#
# This function assigns client scratchpads to the available controllers
# by balancing the total number of requests
#
def bandwidthPartition(controllers, clients, statsFiles):
    
    for fname in statsFiles:
        statsFile = open(fname, 'r')
        for line in statsFile:
            m = re.match("LEAP_SCRATCHPAD_(\d+)_PLATFORM_(\d+)_REQUESTS,.*,(\d+)", line)
            if m:
                client = next((x for x in clients if x.id == m.group(1)), None)
                if client != None: 
                    client.bandwidth = int(m.group(3))
        statsFile.close()     
    
    clients.sort(key=lambda x: x.bandwidth, reverse=True)
    
    network = {}
    num_groups = len(controllers)
    total_bandwidth = [0]*num_groups
    ringstops = [x[:] for x in [[]]*num_groups]
    idx = 0
    for client in clients:
        if client.bandwidth > 0: 
            idx = total_bandwidth.index(min(total_bandwidth))
        else:
            idx = map(len, ringstops).index(min(map(len, ringstops)))
        total_bandwidth[idx] += client.bandwidth
        ringstops[idx].append(client)
    for i, c in enumerate(controllers):
        network[c] = ringstops[i]
    
    print "bandwidthPartition: total bandwidth = " + str(total_bandwidth)
    
    return network

#
# This function assigns client scratchpads to the available controllers
#
def connectScratchpadChains(controllers, clients, scratchpadStats):
    if len(scratchpadStats) > 0:
        return bandwidthPartition(controllers, clients, scratchpadStats)
    else:
        network = {}
        num_groups = len(controllers)
        ringstops = [x[:] for x in [[]]*num_groups]
        clients_per_group = int(math.ceil(float(len(clients))/num_groups))
        for i, c in enumerate(clients):
            idx = i/clients_per_group
            ringstops[idx].append(c)
        for i, c in enumerate(controllers):
            network[c] = ringstops[i]
        return network

#
# This function prints out the scratchpad network
#
def printNetwork(network):
    for controller in network: 
        msg = controller + ": [ "
        for i, client in enumerate(network[controller]):
            if i > 0:
                msg += ", "
            msg += client.id
        print msg, "]"
    
#
# This function outputs the remapping function in the bsh wrapper 
#
def genRemapWrapper(network, fileLists):
    refFile = fileLists.pop()
    fileHandle = open(refFile, 'w')
    fileHandle.write("// Generated by build pipeline\n\n")
    fileHandle.write("function String connectionNameRemap(String inputName);\n")
    fileHandle.write("    String outputName = inputName;\n")
    for controller in network: 
        clients = network[controller]
        for client in clients:
            fileHandle.write("    if (inputName == \"" + client.ringBaseName + "_Req_" + client.id + "\")\n    begin\n")
            fileHandle.write("        outputName = \"" + controller + "_Req\";\n    end\n")
            fileHandle.write("    else if (inputName == \"" + client.ringBaseName + "_Resp_" + client.id + "\")\n    begin\n")
            fileHandle.write("        outputName = \"" + controller + "_Resp\";\n    end\n")
    fileHandle.write("    return outputName;\n")
    fileHandle.write("endfunction\n")
    fileHandle.close()
    
    for file in fileLists:
        shutil.copy2(refFile, os.path.dirname(file))

#
# This function is the top function that handles scratchpad connection remapping
#
def remapScratchpadConnections(liModules, fileLists, scratchpadStats):
    print "remapScratchpadConnections: "
    scratchChains = []
    for liModule in liModules:
        for chain in liModule.chains:
            if re.search("^Scratchpad_", chain.name):
                print "Find Scratchpad Chain: " + chain.name + " in module: " + chain.module_name
                scratchChains.append(chain.name)
        
    controllers, clients = separateScratchpadChains(scratchChains)
    network = connectScratchpadChains(controllers, clients, scratchpadStats)
    printNetwork(network)
    genRemapWrapper(network, fileLists)
